# AIコーディングツール導入メリット

## 概要

他社事例により、AIコーディングツール導入のメリットが多数報告されています。本ドキュメントでは、実際のプロジェクトに参画して検証を進めた結果をまとめています。

### 前提

AIコーディングツールは様々なツールが存在しますが、今回は導入までの工数とAI戦へのヒアリングにより、**GitHub Copilot**を検証しました。

---

## 他社事例

以下のような事例が報告されています：

- [NTTドコモ開発者ブログ - GitHub Copilot導入事例](https://nttdocomo-developers.jp/entry/2024/12/22/090000_3)
- [Microsoft - 日立製作所のGitHub Copilot導入事例](https://www.microsoft.com/ja-jp/customers/story/22781-hitachi-github?msockid=2572712caf5f66a3205f6423ae3b67a4)

---

## 検証の狙い

本検証では、以下の2点を主な目的として実施しました：

### 1. 開発効率の向上
- AIのサポートにより、コーディング時間や検索時間を短縮
- リリースまでのリードタイムを短縮する

### 2. エンジニアの負担軽減
- 生成AIのサポートにより、内容理解や検索時間の負荷を軽減
- 実装中のフラストレーションを減らし、エンジニアが集中して作業できる環境を構築

---

## 検証結果

### プロト作成
（検証結果を記載予定）

### 一画面作成
（検証結果を記載予定）

### 複数画面作成 + API連携
（検証結果を記載予定）

---

## 検証結果から考える導入効果

検証結果から、以下のような効果が期待できることが明らかになりました：

- **大きな効果が期待できる**: 適当に利用するだけでも、検証結果のように大きな効果が期待できることは明白
- **プロトタイプ作成で特に効果的**: 特にプロトタイプ作成の段階では、特に効果的であることが確認できた
- **本番運用には注意が必要**: ただし、本番運用を考慮したコードを作成するためには、以下のポイントに注意する必要がある

---

## AIコーディングツール利用時の注意点

### 課題1: コードの責任と判断
**内容**: 最終的なコードの正否やリスク判断はエンジニア自身で行う必要がある。プルリクエストを出すタイミングでは、自分自身が記載したコードだという責任を持つ。

### 課題2: AI出力の理解
**内容**: AIの出力は徹底的に読み込み理解する。理解できないところはAI自身に初心者にも分かりやすいように説明してもらう。

### 課題3: コードレビューの効率化の限界
**内容**: 上記の観点からも、最終的にはエンジニア自身がコードの正しさやリスクを判断する必要があるため、プルリクエストのレビュー自体を効率化させることは難しい。

### 課題4: プロジェクト内の共通機能の考慮不足
**内容**: プロジェクト内の共通機能の利用や共通化等は考慮してくれないケースがある。

### 課題5: プロジェクト特有のDoDの考慮不足
**内容**: プロジェクト特有のDoD（Definition of Done）を考慮しないケースが多い（例：リンター、フォーマッター）。

### 課題6: 共通基盤の存在
**内容**: 共通基盤（認証、ユーザー管理）が別に存在していると、AIツールの活用がやりづらい。

---

## 課題を踏まえたGitHub Copilotのさらなる活用方法

上記の課題の解決を目指し、**カスタムエージェント**と**cc-sdd（仕様駆動開発）**の2つの手法を検証しました。

> **注意**: 今後より良い方法が現れる可能性があります。また、手法の検証も完全には完了していません。

---

## 1. カスタムエージェントの活用

### 1.1 カスタムエージェントとは

カスタムエージェントは、GitHub Copilotの機能の一つで、プロジェクトやチームのニーズに合わせた専門的なAIアシスタントを構築できる機能です。従来の汎用アシスタントではなく、バックエンド専用の `@backend-specialist`、フロントエンド専用の `@frontend-specialist`、SRE専用の `@sre-specialist` など、専門性をGitHub Copilotに定義することができます。

**参考**: [GitHub Copilot カスタムエージェントのための agents.md 作成ベストプラクティス](https://zenn.dev/studypocket/articles/github-copilot-agents-md-best-practices)

### 1.2 カスタムエージェントが課題を解決する理由

#### 課題4・5・6への対応
- **プロジェクト内の共通機能の考慮**: エージェントにプロジェクト構造や共通機能の使用方法を定義することで、適切に共通機能を利用したコードを生成
- **プロジェクト特有のDoDの考慮**: リンター、フォーマッター、テスト要件などをエージェントに明示することで、プロジェクトのDoDに準拠したコードを生成
- **共通基盤の理解（未検証）**: 認証やユーザー管理などの共通基盤の使用方法をエージェントに定義することで、適切に連携したコードを生成（※検証は未完了）

### 1.3 カスタムエージェントの作成方法

#### ファイルの配置

`.github/agents/` ディレクトリに、エージェントごとの `.agent.md` ファイルを作成します。

```
.github/
└── agents/
    ├── backend-specialist.agent.md
    ├── frontend-specialist.agent.md
    └── sre-specialist.agent.md
```

#### YAMLフロントマターの設定

各 `.agent.md` ファイルの冒頭に、エージェントのメタデータをYAML形式で記述します。

```yaml
---
name: backend-specialist
description: バックエンド開発に特化したエージェントです。RESTful APIの実装とデータベース操作を担当します。
tools: ['read', 'edit', 'search', 'shell']
target: vscode
---
```

**主要な設定項目**:
- `name`: エージェントの表示名
- `description`: エージェントの目的や専門領域（**必須**）
- `tools`: 使用可能なツール（`read`, `edit`, `search`, `shell` など）
- `target`: 使用環境（`vscode` または `github-copilot`）

### 1.4 効果的なagents.mdに必要な6つの要素

GitHubが2,500以上のリポジトリを分析した結果、優れたagents.mdには以下の6つの要素が必要とされています：

#### 1. コマンド（Commands）
エージェントが実行できる具体的なコマンドを明記します。

```markdown
## 実行可能なコマンド

- テスト実行: `npm test --coverage`
- リント: `npm run lint --fix`
- ビルド: `npm run build`
- 型チェック: `npm run type-check`
```

#### 2. テスト（Testing）
使用するテストフレームワークとその実行方法を記述します。

```markdown
## テスト

- テストフレームワーク: Jest + React Testing Library
- テストファイルの配置: `__tests__` ディレクトリ
- テスト実行コマンド: `npm test`
- カバレッジ目標: 80%以上
```

#### 3. プロジェクト構造（Project Structure）
ディレクトリ構造や重要なファイルの配置を説明します。

```markdown
## プロジェクト構造

- `/src/components/`: Reactコンポーネント
- `/src/utils/`: 共通ユーティリティ関数
- `/src/hooks/`: カスタムフック
- `/src/api/`: API呼び出し関数
- `/src/types/`: TypeScript型定義
```

#### 4. コードスタイル（Code Style）
プロジェクトで採用しているコードスタイルやリントルールを示します。

```markdown
## コードスタイル

- ESLint設定: `.eslintrc.json` に従う
- Prettier設定: `.prettierrc` に従う
- 命名規則: コンポーネントはPascalCase、関数はcamelCase
- インポート順序: 外部ライブラリ → 内部モジュール → 相対パス
```

#### 5. Gitワークフロー（Git Workflow）
開発プロセスやCI/CDパイプラインの流れを示します。

```markdown
## Gitワークフロー

- ブランチ命名規則: `feature/`, `fix/`, `hotfix/`
- コミットメッセージ: Conventional Commits形式
- PR作成前に: リント、テスト、ビルドが通ることを確認
- レビュー要件: 最低1名の承認が必要
```

#### 6. 境界線（Boundaries）
エージェントが遵守すべき制約や禁止事項を明確にします。

```markdown
## やってはいけないこと

- 既存の共通機能（`src/utils/auth.ts`）を再実装しない
- プロジェクトのアーキテクチャパターンに反する実装をしない
- テストコードを書かずに実装を完了しない
- セキュリティベストプラクティスを無視しない
```

### 1.5 段階的な改善アプローチ

完璧なagents.mdを最初から作ろうとしてはいけません。ゆえに私たちが提供するサンプルも限りなくシンプルな記載にしています。シンプルに始めて、実際の運用から改善を重ねていくことが重要です。

#### Step 1: 最小限からスタート

```markdown
---
name: test-agent
description: テストを書くエージェント
---

あなたはテストを書くエンジニアです。
テストフレームワークは Jest を使います。
```

#### Step 2: 問題が起きたら追記

エージェントが意図しない動作をしたら、その経験をもとに境界線やルールを追加していきます。

```markdown
## 追加したルール（実際の問題から学んだこと）

- テストファイルは `*.test.ts` の命名規則に従う
- モックは `__mocks__` ディレクトリに配置する
- 非同期テストには必ず `await` を使用する
- プロジェクトの共通機能（`src/utils/auth.ts`）を必ず使用する
```

---

## 2. cc-sdd（仕様駆動開発）の活用

### 2.1 cc-sddとは

cc-sddは、AIと協働して仕様駆動開発（Specification-Driven Development）を進めるためのツールです。このツールを活用することで、要件定義から設計、実装計画、実装までのプロセスをAIと対話的に進めることが可能となります。

**参考**: [初心者でもわかる「cc-sdd」〜AIと進める仕様駆動開発の第一歩〜](https://zenn.dev/7788/articles/ec5c80a32279b5)

### 2.2 cc-sddが課題を解決する理由

#### 課題1・2・3への対応
- **コードの責任と判断の明確化**: 仕様書に基づいて実装することで、要件と実装の対応関係が明確になり、エンジニアがコードの正否を判断しやすくなる
- **AI出力の理解促進**: 仕様書→設計書→実装という段階的なプロセスにより、各段階でAIの出力を理解・確認できる
- **コードレビューの効率化**: 仕様書と実装の対応関係が明確になることで、レビュー時の確認ポイントが明確化される

### 2.3 開発フロー

cc-sddでは、以下のコマンドを使用して開発を進めます：

1. **プロジェクトの初期化**
   ```bash
   /kiro:spec-init <プロジェクト名>
   ```
   - 仕様書フォルダを自動生成
   - プロジェクトの概要をまとめる

2. **要件定義の詳細化**
   ```bash
   /kiro:spec-requirements <スペック名>
   ```
   - AIと対話しながら、必要な機能や条件を整理
   - 受け入れ条件を明確化

3. **設計書の作成**
   ```bash
   /kiro:spec-design <スペック名>
   ```
   - データ構造や画面設計などを自動生成
   - API仕様やデータベース設計を明確化

4. **実装計画の策定**
   ```bash
   /kiro:spec-tasks <スペック名>
   ```
   - 実装タスクを一覧化
   - 開発手順を明確化

5. **実装**
   ```bash
   /kiro:spec-impl <スペック名>
   ```
   - 仕様書と設計書に基づいてコードを生成
   - AIと共同で開発を進める

### 2.4 cc-sddの主な機能と利点

#### 要件定義の自動化
- `/kiro:spec-init` コマンドで、仕様書フォルダを自動生成し、プロジェクトの概要をまとめます
- AIと対話しながら要件を整理することで、漏れのない要件定義が可能

#### 設計の支援
- `/kiro:spec-design` コマンドで、データ構造や画面設計などを自動生成し、設計プロセスを効率化します
- 仕様書に基づいた一貫性のある設計が可能

#### 実装計画の明確化
- `/kiro:spec-tasks` コマンドで、実装タスクを一覧化し、開発手順を明確にします
- 開発の見積もりや進捗管理が容易に

#### ドキュメントの自動生成
- AIが生成した仕様や設計がフォルダに整理されるため、ドキュメント作成の手間が削減されます
- 仕様書と実装の対応関係が明確になり、保守性が向上

#### 手戻りの削減
- 仕様→設計→実装という段階的なプロセスにより、各段階で確認・修正が可能
- 実装後の手戻りを大幅に削減

#### チーム内での情報共有
- 仕様書や設計書が自動的にドキュメント化されるため、チーム内での情報共有が容易
- 新メンバーのオンボーディングも迅速に

---

## まとめ

今回、課題解決に効果的な手法として**カスタムエージェント**と**cc-sdd（仕様駆動開発）**を提案しましたが、これらの手法はAIコーディングツールの進化とともに有用な手法が変化していくと考えられます。例えば、カスタムエージェント内の記載も常にアップデートしていく必要があると思っています。

ただし、有用な手法が決まっていなくても、AIコーディングツールを効果的に利用している開発者とそうでない開発者で大きくアウトプットの速度に差が出始めると思っています。

重要なこととしては、AIコーディングツールを徹底的に使いつくして、AIのアウトプットにしっかり向き合い、AIの弱点や課題を常に意識して、どうやってその課題を人の力で解決していくのかを向き合っていくことが重要だと考えています。
